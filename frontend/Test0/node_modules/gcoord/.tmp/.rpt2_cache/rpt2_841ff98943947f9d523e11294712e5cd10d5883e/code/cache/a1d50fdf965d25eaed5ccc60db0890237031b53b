{"code":"export function assert(condition, msg) {\r\n    if (condition)\r\n        throw new Error(msg);\r\n}\r\nexport function error(message) {\r\n    throw new Error(message);\r\n}\r\n/**\r\n * isNumber\r\n *\r\n * @param {*} num Number to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * isNumber(123)\r\n * //=true\r\n * isNumber('foo')\r\n * //=false\r\n */\r\nexport function isNumber(input) {\r\n    return !isNaN(input) && input !== null && !isArray(input);\r\n}\r\n/**\r\n * isString\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n */\r\nexport function isString(input) {\r\n    return typeof input === 'string';\r\n}\r\n/**\r\n * isObject\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * isObject({elevation: 10})\r\n * //=true\r\n * isObject('foo')\r\n * //=false\r\n */\r\nexport function isObject(input) {\r\n    return (!!input) && (input.constructor === Object);\r\n}\r\n/**\r\n * isArray\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n */\r\nexport function isArray(input) {\r\n    return (!!input) && Object.prototype.toString.call(input) === '[object Array]';\r\n}\r\n/**\r\n * compose\r\n *\r\n * @param {function[]} functions\r\n * @returns {function}\r\n */\r\nexport function compose() {\r\n    var funcs = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        funcs[_i] = arguments[_i];\r\n    }\r\n    var start = funcs.length - 1;\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var i = start;\r\n        var result = funcs[start].apply(null, args);\r\n        while (i--)\r\n            result = funcs[i].call(null, result);\r\n        return result;\r\n    };\r\n}\r\n/**\r\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\r\n * https://github.com/Turfjs/turf/blob/master/packages/turf-meta/index.mjs\r\n *\r\n * @name coordEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {void}\r\n * @example\r\n * let features = featureCollection([\r\n *   point([26, 37], {\"foo\": \"bar\"}),\r\n *   point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\n/* eslint-disable no-param-reassign */\r\nexport function coordEach(geojson, callback, excludeWrapCoord) {\r\n    if (excludeWrapCoord === void 0) { excludeWrapCoord = false; }\r\n    // Handles null Geometry -- Skips this GeoJSON\r\n    if (geojson === null)\r\n        return;\r\n    /* eslint-disable-next-line */\r\n    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection;\r\n    var type = geojson.type;\r\n    var isFeatureCollection = type === 'FeatureCollection';\r\n    var isFeature = type === 'Feature';\r\n    var stop = isFeatureCollection ? geojson.features.length : 1;\r\n    // This logic may look a little weird. The reason why it is that way\r\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n    // of objects at its root: FeatureCollection, Features, Geometries.\r\n    // This function has the responsibility of handling all of them, and that\r\n    // means that some of the `for` loops you see below actually just don't apply\r\n    // to certain inputs. For instance, if you give this just a\r\n    // Point geometry, then both loops are short-circuited and all we do\r\n    // is gradually rename the input until it's called 'geometry'.\r\n    //\r\n    // This also aims to allocate as few resources as possible: just a\r\n    // few numbers and booleans, rather than any temporary arrays as would\r\n    // be required with the normalization approach.\r\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\r\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry\r\n            : (isFeature ? geojson.geometry : geojson));\r\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\r\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\r\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\r\n            var multiFeatureIndex = 0;\r\n            var geometryIndex = 0;\r\n            geometry = isGeometryCollection\r\n                ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\r\n            // Handles null Geometry -- Skips this geometry\r\n            if (geometry === null)\r\n                continue;\r\n            var geomType = geometry.type;\r\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\r\n            switch (geomType) {\r\n                case null:\r\n                    break;\r\n                case 'Point':\r\n                    coords = geometry.coordinates;\r\n                    if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\r\n                        return false;\r\n                    coordIndex++;\r\n                    multiFeatureIndex++;\r\n                    break;\r\n                case 'LineString':\r\n                case 'MultiPoint':\r\n                    coords = geometry.coordinates;\r\n                    for (j = 0; j < coords.length; j++) {\r\n                        if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\r\n                            return false;\r\n                        coordIndex++;\r\n                        if (geomType === 'MultiPoint')\r\n                            multiFeatureIndex++;\r\n                    }\r\n                    if (geomType === 'LineString')\r\n                        multiFeatureIndex++;\r\n                    break;\r\n                case 'Polygon':\r\n                case 'MultiLineString':\r\n                    coords = geometry.coordinates;\r\n                    for (j = 0; j < coords.length; j++) {\r\n                        for (k = 0; k < coords[j].length - wrapShrink; k++) {\r\n                            if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\r\n                                return false;\r\n                            coordIndex++;\r\n                        }\r\n                        if (geomType === 'MultiLineString')\r\n                            multiFeatureIndex++;\r\n                        if (geomType === 'Polygon')\r\n                            geometryIndex++;\r\n                    }\r\n                    if (geomType === 'Polygon')\r\n                        multiFeatureIndex++;\r\n                    break;\r\n                case 'MultiPolygon':\r\n                    coords = geometry.coordinates;\r\n                    for (j = 0; j < coords.length; j++) {\r\n                        geometryIndex = 0;\r\n                        for (k = 0; k < coords[j].length; k++) {\r\n                            for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\r\n                                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\r\n                                    return false;\r\n                                coordIndex++;\r\n                            }\r\n                            geometryIndex++;\r\n                        }\r\n                        multiFeatureIndex++;\r\n                    }\r\n                    break;\r\n                case 'GeometryCollection':\r\n                    for (j = 0; j < geometry.geometries.length; j++) {\r\n                        if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\r\n                            return false;\r\n                    }\r\n                    break;\r\n                default:\r\n                    error('Unknown Geometry Type');\r\n            }\r\n        }\r\n    }\r\n}\r\n","dts":{"name":"D:/work/gcoord/dist/types/helper.d.ts","writeByteOrderMark":false,"text":"import { GeoJSON } from './geojson';\r\nexport declare function assert(condition: boolean, msg: string): void | never;\r\nexport declare function error(message: string): never;\r\n/**\r\n * isNumber\r\n *\r\n * @param {*} num Number to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * isNumber(123)\r\n * //=true\r\n * isNumber('foo')\r\n * //=false\r\n */\r\nexport declare function isNumber(input: any): input is number;\r\n/**\r\n * isString\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n */\r\nexport declare function isString(input: any): input is string;\r\n/**\r\n * isObject\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * isObject({elevation: 10})\r\n * //=true\r\n * isObject('foo')\r\n * //=false\r\n */\r\nexport declare function isObject(input: any): input is object;\r\n/**\r\n * isArray\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n */\r\nexport declare function isArray(input: any): input is any[];\r\n/**\r\n * compose\r\n *\r\n * @param {function[]} functions\r\n * @returns {function}\r\n */\r\nexport declare function compose(...funcs: Function[]): (...args: any[]) => any;\r\n/**\r\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\r\n * https://github.com/Turfjs/turf/blob/master/packages/turf-meta/index.mjs\r\n *\r\n * @name coordEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {void}\r\n * @example\r\n * let features = featureCollection([\r\n *   point([26, 37], {\"foo\": \"bar\"}),\r\n *   point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nexport declare function coordEach(geojson: GeoJSON, callback: Function, excludeWrapCoord?: boolean): boolean | void | never;\r\n"}}
